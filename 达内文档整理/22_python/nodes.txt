张众磊 微信:teduzzl 邮箱:bjzhangzl@tedu.cn

推荐项目:
 1、vue中很棒的组件库
 https://github.com/vuejs/awesome-vue
 和过滤器相关的：
 https://github.com/freearhey/vue2-filters
 路由守卫:
 https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB

 2、angular
 angular.cn
 https://github.com/PatrickJS/awesome-angular
 
 ng-cli所支持的创建时的选项:
  https://angular.io/cli/generate#service
 
 3、rxjs 微软所提出处理异步请求的js的实现
  https://cn.rx.js.org/
  
 4、方便调试
  http://www.bejson.com/ json校验

  fake api（方便测试的假数据）:
  http://jsonplaceholder.typicode.com/users
  http://jsonplaceholder.typicode.com/albums
 
 5、ionic
  官网:  ionicframework.com
  官方手册: https://ionicframework.com/docs/v3/components/#buttons
  icon: ionicons.com
 
 6、React
  https://github.com/enaqx/awesome-react
  https://github.com/jondot/awesome-react-native
  https://facebook.github.io/react-native/docs/getting-started

  做原生开发：
   https://weex.apache.org/zh/guide/introduction.html
   https://facebook.github.io/react-native/docs/view
   https://flutter.dev/

 7、python
  https://docs.python.org/3/tutorial/index.html
 
 8、django
  djangoproject.com
  https://docs.djangoproject.com/zh-hans/2.1/
  https://github.com/wsvincent/awesome-django
  django定义模型类 使用的类型:
  https://docs.djangoproject.com/zh-hans/2.1/ref/models/fields/

建议:
 1、数据的操作
  定义\读\写
 2、处理问题策略
  从数据着手--》显示--》交互
 3、网络通信
  ①请求的地址
  ②请求的方式
  ③请求中是否需要参数，几个参数、什么类型
  ④跨域处理
  ⑤withCredentials
  ⑥服务器端所返回的数据格式
 4、常见的错误
  can't read property ** of undefined
  检查下一个变量认为有值，其实undefined


学习计划:
 1、Angular以及生态圈
   完成中大型SPA的开发
   完成webApp的开发
 2、React以及生态圈
   完成React基于web的页面开发
   完成原生app开发
 3、Python以及生态圈
   完成python基础语法的学习
   完成django全栈类框架的学习



一、Vue以及生态圈
 1、Vue的技术栈(生态圈):
  vue核心库、vueRouter、vuex
  Element/Mint、weex、vux、axios

 2、vue基础语法
   :src
   @click
   v-model
   v-for="tmp in list"
   v-if/else-if/else

   常见属性:
     computed
     methods
     data
     watch
     props
     components
     filters
     ....

 3、vue组件
  组件?? 可被反复使用的，带有特定功能的视图

  支持.vue结尾的文件，称为单文件组件系统single file component
  Vue.component('my-component',{})
  Vue.component('',{
   components:{}
  })

  <my-component></my-component>

 4、vue组件间通信
  父--》子 props down
   <son myName='Michael'></son>
   
   Vue.component('son',{
     props:['myName']//this.myName
   })
   
  子--》父 events up
   rcvMsg(msg){}
   <son @myEvent="rcvMsg"></son>

   this.$emit('myEvent',123)

  兄弟 event bus
   var bus = new Vue()
   //接收方
   bus.$on('myEvent',(msg)=>{})
   //发送方
   bus.$emit('myEvent',123)
  
  ref(父组件主动的到子组件取值)
  <son ref='mySon'></son>
  this.$refs.mySon

  $parent
  this.$parent 找到父组件的实例对象

 5、服务器端的通信
   npm i axios
   import Axios from 'axios'
   Axios.get/post().then((response)=>{
     //response.data
   })

 6、路由功能
  路由模块:建立起一种映射关系

  6.1 基础用法
   指定容器 router-view
   创建组件
   路由词典：在vue中，是一个由多个路由对象构成的数组
    {path:'',component:'',children:[],****}

   调用路由
    new Vue({
      router:new VueRouter({
        routes:***
      })
    })
  6.2 跳转传参
   this.$router.push()
   this.$router.pop()
   this.$router.go(-1)
   <router-link to="/login"></router-link>

   路由传参:在借助于路由模块进行页面切换时，同时指定数据
   /detail-->/detail/:id

   this.$router.push('/detail/3')

   this.$route.params.id
  6.3 路由嵌套
   一个SPA中，有一个页面，这个页面需要继续通过二级路由来访问其他的嵌套子页面
   

    {
      path:'',
      component:**,
      children:[
        {},
	{}
      ]
    }
     比如A组件需要嵌套B\C
     步骤1：A指定一个容器 router-view
     步骤2: 配置A的路由对象 
      {
        path:'/a',
	component:A,
	children:[
	  {}
	]
      }

      
  6.4 路由守卫
  6.5 动态添加路由
  6.6 懒加载

 7、vuex
  state 数据的定义
  getters 在state数据基础之上派生新数据
  mutations 修改数据
  actions 执行异步操作，但是涉及到数据的修改依然得通过mutation
  modules 将数据和操作拆分

二、设计原则
 1、YAGNI
  You aren't gonna need it
  不要写不需要的代码

 2、KISS
  Keep it simple and stupid
  保证代码足够的简单
  变量、文件、方法、注释
 
 3、OCP
  open close principle 开闭原则
  对于扩展是开放的
  对于修改是关闭的

 4、SRP 
  single responsiblity principle
  单一责任原则
  每一个文件、每一个方法、每一个组件只做一件事
 
 5、高内聚、低耦合
  耦合度所指的是不同部分之间的关系

三、Angular
 0、生态圈
  angular核心库core、HttpModule、FormsModule RouterModule
  ionic(移动端)
  AngularMaterial（桌面端）
  NgZorro(桌面端)

 1、Angular概述
  what?
    angular是由Google所推出的js框架，是以模块为基本单位，模块本身也是一个容器，可以包含组件、指令、管道、服务
  when?
    angular针对中大型SPA
  
  why?
   内置了丰富的类，功能很强大
   采用了强类型约束的语言ts(TypeScript)
   支持模块化的开发，在模块中又可以继续封装组件
   更好的可读性和可维护性
   强大的cli支持

  how?
    angular是如何来工作的？？
     是靠组件的封装来完成视图的编写
     是靠服务的封装来完成共享数据或者方法的处理
     是靠指令、管道来增强html的功能
     是靠模块的封装来完成业务大功能的拆分和处理
     。。。。

    搭建angular开发环境:
    npm install -g @angular/cli
    ng new my-app
    cd my-app
    ng serve --open/npm start
    
    具体步骤:
    ①forStu.zip拷贝到C:\xampp\htdocs\codes
    解压缩到forStu
    ②拷贝forStu文件夹中Angular.rar
    到C:\xampp\htdocs\codes\ng文件中
    ③将Angular.rar直接解压缩到当前目录

    npm start

  启动流程?
   main.ts-->启动根模块(src/app/app.module.ts)-->根组件(src/app/app.component.ts)
  
  设置环境变量:
   ①找到ng的路径
   C:\xampp\htdocs\codes\ng\myngapp\node_modules\.bin
   ②添加到环境变量
    我的电脑--》右键查看属性--》高级系统设置--》环境变量--》系统变量 Path--》win10新建/win7在输入框分号隔开粘贴对应的路径信息
   ③重新打开了cmd窗口，输入ng查看是否可以使用
   ④win10 建议大家将vscode中默认终端指定为cmd
   文件-》首选项-》设置--用户设置---》
    "terminal.integrated.shell.windows": "C:\\WINDOWS\\System32\\cmd.exe"

    C:\WINDOWS\System32\cmd.exe

     
 2、ng核心概念
  模块、组件、模板、指令、数据绑定
  服务、依赖注入、路由

 3、组件的封装和调用
  组件在ng中的内部实现，是一个带有模板的指令


  组件：可被反复使用的，带有特定功能的视图

  Vue组件的创建和调用：
   Vue.component("",{components:{}})

   <test></test>
  
  angular组件类的创建和调用:
   ng g component demo01
    （背后做的事项：在src的app中创建一个demo01的文件夹，在此文件夹中创建4个文件，同时将Demo01Component注册到根模块）

   调用：
    ①直接设置为根组件
    ②将demo01作为子组件进行调用
     组件的selector属性对应的值是可以直接作为标签来使用
    ③路由来访问
  
  装饰器:TypeDecorator
   指定angular如何来描述当前这个类
   @Component @NgModule @Injectable @Directive @Pipe
   ...
  元数据:metaData
   告诉angular如何来处理当前这个类

 4、ng基础语法（重点）
  4.1 双花括号    
    <any>{{expression}}</any>
  4.2 常用指令:
   4.2.1 循环 *ngFor
    <any *ngFor="let tmp of myList"></any>

    <any *ngFor="let tmp of myList;let myIndex=index"></any>
   4.2.2 条件 *ngIf *ngSwitchCase/Default
    <any *ngIf="expression"></any>
    
    多重条件判断:
    <div [ngSwitch]="answer">
     <p *ngSwitchCase="'a'">A</p>
     <p *ngSwitchCase="'b'">B</p>
     <p *ngSwitchCase="'c'">C</p>
     <p *ngSwitchCase="'d'">D</p> 
     <p *ngSwitchDefault>请输入正确的答案</p>
    </div>
   4.2.3 事件绑定 （）
    <any (click)="rcvMsg"></any>
   4.2.4 属性绑定 []
    <any [someProp]="expression"></any>
    将expression表达式执行的结果绑定指定的someProp属性
   4.2.5 双向数据绑定
     方向1：数据--》视图
     方向2：视图--》数据 （表单元素这些视图中进行操作之后，操作的结果绑定到数据）
     
     ①准备工作
      找到当前组件所属的模块，
      import {FormsModule} from '@angular/forms'

      @NgModule({
        imports:[FormsModule]
      })
     ②调用双向数据绑定
      <表单元素 [(ngModel)]="myValue" />

   注意事项:
   ①结构型指令不可以同时在一个元素上进行调用，通过ng-container来解决此问题
   ②ngModel指令和ngModelChange事件绑定时有先后顺序之分，先做双向数据绑定，其次再是事件绑定


  练习:
   ①创建一个组件demo03-lianxi
   ②在根组件app.component.html中调用demo03-lianxi
   ③在demo03-lianxi的组件类中定义一个整数数组，将数组中内容显示在ul的li
 
   练习:(:- 16:40)
    ①完成demo06-lianxi组件的创建和调用
    ②在demo06-lianxi组件中 初始化一个对象数组(5个对象)，每一个对象都包含以下属性:stuName stuScore stuSex
    ③将对象数组显示在模板中
    模板无序列表，列表项显示学生的姓名，只显示成绩在60分以上的
  
 5、管道(过滤器)
  angulr中是支持内置的过滤器，也支持自定义过滤器

  管道的目的：实现数据在展示时，一些对应的筛选、过滤、格式化
  
  管道(过滤器)的本质：一个有参数有返回值的方法

  Vue中管道的用法:
   <any>{{expression | myFilter1(1,2)}}</any>
  
  Angular:
   语法：
   ①<any>{{expression | myFilter1:1:2}}</any>
   ②多重过滤
   <any>{{expression | myFilter1 | myFilter2 | myFilter3}}</any>

   内置的管道:
    currency
    number
    percent
    slice:start:end
    uppercase
    lowercase
    json
   
   自己的管道:
    ①自定义管道:
     ng g pipe sex
    ②实现管道的具体要求:(重点)
     实现transform方法，在此方法，针对value所对应的数据，根据管道的功能要求做处理，最后返回处理后的数据
    ③调用管道
     管道的名字取决于管道类在定义是元数据中的name对应的值
    
   练习:
    ①实现一个自定义的管道 even
     目的：实现一个筛选
     传递一个数组，返回偶数构成的数组
    ②在demo10-pipe调用自定义管道   
 
 练习:
  组件的用法
  ①完成demo09-lianxi的组件的创建和调用
  ②模板内容:
   一个输入框 一个按钮(添加)，一个ul
  ③点击按钮，将输入框的值显示ul的li
 
 6、组件间通信（重点）
   6.1 父--》子 props down （Input）
     vue:
       <son myName='zhangsan'></son>
       props:['myName']//this.myName
     Angular:
       ①传值
        <app-demo11-header myTitle="购物车">
	</app-demo11-header>
       ②接收值
        import {Input} from '@angular/core'

	@Input() myTitle = ""

	this.myTitle/直接在模板中myTitle

   6.2 子--》父 events up （$event/Output/EventEmitter）
     vue:
      步骤1：事件的绑定
      rcvMsg(msg){}
      <son @myEvent="rcvMsg"></son>
      步骤2：触发事件进行传值
      this.$emit('myEvent',0)
     Angular:
      步骤1：事件的绑定
       rcvMsg(msg){}
       <son (myEvent)="rcvMsg($event)"></son>
      步骤2：事件的触发
       import {Output,EventEmitter} from '@angular/core'
       
       @Output() myEvent = new EventEmitter()

       this.myEvent.emit(0)

   6.3 兄弟通信
     vue:
       借助于event bus 来处理
       var bus = new Vue()
       bus.$on('myEvent',(msg)=>{})
       bus.$emit('myEvent',123)
     angular:
       ①借助于共同的父组件
       ②借助于服务
        父子组件以及兄弟组件之间，可以借助于服务来实现通信，实例化得来的服务指向的是同一块内存地址(同一个服务类的实例对象)

	demo24-cart --> 路由地址cart
	demo24-header
	demo24-list
	步骤1：创建一个服务
	 ng g service communcation
	步骤2：在服务中封装一些方法完成数据的读/写操作
	步骤3：组件如果需要发送数据，可以调用服务的写操作，保存在服务的变量；如果需要接受数据，调用服务的读操作，读取服务中之前保存的数据

  
 
 7、服务
  服务是遵循单例(single instance 单个实例)设计模式

  服务是可以将不同的组件之间要共享的数据或者方法封装在一个类中，以方便提高代码的可读性、可维护性、复用性

  举例：实现一个服务，来封装检查用户权限的方法、封装日志功能、。。。。

  7.1 服务的创建
   ng g service log

  7.2 服务的调用
   import {LogService} from '../log.service'

   实例化:将一个类变成一个对象的过程
   constructor(private myService:LogService){}

   this.myService.***

   练习:(:- 15:30)
    ①实现一个心跳服务 beat
     在服务中 封装两个方法，一个startBeat(启动一个定时器，每隔1s输出‘正在心跳’)，另外一个stopBeat(结束定时器的运行)
    ②完成组件demo14-order的创建和调用
     模板：俩按钮，点击按钮，分别调用服务中startBeat/stopBeat
    
    涉及的知识点:
    ①服务从创建到封装到调用一个完整流程
    ②定时器需要反复开闭，要记得指定一个开关

  
 8、与远程服务器端的通信(HttpClient/HttpClientModule/subscribe)
  Vue:
   npm i axios
   import Axios from 'axios'
   Axios.get/post().then()
  
  Angular:
   自带网络请求处理：使用HttpClient这个类来完成服务器端的通信工作，但是当前组件所属模块依赖于HttpClientModule


  异步处理:
   ajax
   promise
   async/await
   callback
   rxjs：微软所提出的一个基于Observable的(观察者-订阅者设计模式)的js异步处理的库


  具体步骤：
   ①让根模块依赖于HttpClientModule
    app.module.ts
    import {HttpClientModule} from '@angular/common/http'

    @NgModule({
      imports:[HttpClientModule]
    })
   
   ②调用
    import {HttpClient} from '@angular/common/http'

    constructor(private myHttp:HttpClient){}


    this.myHttp.get(url).subscribe((result)=>{
      //result就是服务器端所返回的数据
    })

  
  xz_api.zip放到C:/xampp/htdocs/codes
  将压缩包解压缩到xz_api文件夹中
  准备工作:
   ①启动xampp的mysql数据库服务器
   ②启动node编写app.js对应的http服务器
   (C:\xampp\htdocs\codes\xz_api\app.js)
    node app.js
    
    http://localhost:8080/product/list
  
  练习:
   ①完成demo16-lianxi组件的创建和调用
   ②组件模板:
     ul、button
   ③业务
     点击button，向指定的url发送请求http://localhost:8080/product/list，将请求到的数据保存，到ul中显示，li显示商品的标题

     进阶要求：
      在点击button，请求下一页的数据，将请求到的新数据和老的数据拼接在一起（concat）
   

 9、路由
  SPA的工作原理：
   ①解析地址栏
    http://localhost:4200/login
   ②拿到路由地址
    login
   ③从路由词典中匹配，指定的路由地址要加载那个组件
    Demo17LoginComponent
   ④将Demo17LoginComponent组件类进行实例化，将模板内容，插入到路由出口(RouterOutlet)

  what?
    路由都是为了建立起一种映射关系
  why?
    为了更快的实现SPA(single page application)
  how?
    ①可以将路由功能单独的封装在一个模块中
    ng g module route --routing

    route.routing.module.ts-->
     修改forChild-->forRoot
    ②让根模块依赖于自定义包含路由功能的模块
     app.module.ts

     import {RouteRoutingModule} from '***'

     @NgModule({
      imports:[RouteRoutingModule]
     })
  9.1 基础用法(重点)
     ①指定容器
      <router-outlet></router-outlet>
     
     ②创建组件
      ng g component demo17-login
      ng g component demo17-register
    
     ③设置路由词典(路由词典的本质就是一个数组，数组是由多个路由对象构成，路由对象path/component/children/...)
      
      const routes:Routes = [
        {
	 path:'login',
	 component:Demo17LoginComponent,
	 children:[],
	 canActivate:[],
	 redirectTo:""
	}，
	{}，
      ]

     ④测试路由有没有生效
      在浏览器的地址栏输入指定的路由地址测试是否加载了指定的组件
      localhost:4200/login

     ⑤路由匹配规则
      第一点:
       路由地址为空--》 ""
       具体的路由地址--》"login"
       异常处理-->'**'
       注意事项：路由地址在定义时不能以'/'开头，否则是会报错的
      第二点：
       先后顺序，默认从路由数组的第0个开始匹配
      第三点：
       路由对象支持的属性
       (https://www.angular.cn/api/router/Routes)
        path
	component
	children
	redirectTo
    
     练习: 
       ①完成两个组件的创建
         demo18-list demo18-detail
       ②指定默认访问demo18-list,路由地址是detail访问demo18-detail


  9.2 跳转、传参 (重点Router/routerLink/ActivatedRoute)
    知识回顾Vue：
     <router-link to="/login"></router-link>
     this.$router.push()
    
    angular跳转:
     ①编程式导航:
      import {Router} from '@angular/router'
      constructor(private myRouter:Router){}
      this.myRouter.navigateByUrl('/login')  
     ②RouterLink
      <any routerLink="/detail"></any>


     练习: (:- 14:20)
     ①完成两个组件类的创建以及路由的分配
     路由地址为空--> demo19-list 
     路由地址为detail--> demo19-detail
     ②demo19-list
      初始化一个整数数组，将数组中数据遍历在ul中创建多个li（p显示数组中的数据
      button），点击li的button，跳转到detail所对应的组件

    angular传参:
      Vue的处理思路：
       ①配置接收方的路由地址
        /detail -->/detail/:id
       ②发送
        this.$router.push('/detail/2')
       ③接收
        this.$route.params.id
      
      angular：
        ①配置接收方的路由地址
         detail -->detail/:id
	②发送
	 this.myRouter.navigateByUrl('/detail/10')
	 this.myRouter.navigateByUrl('/detail/'+this.uName)
	 <any routerLink="/detail/10"></any>
	 <any routerLink="/detail/{{myId}}"></any>
	 <any [routerLink]="'/detail/'+myId"></any>
	③接收
	 import {ActivatedRoute} from '@angular/router'

	 constructor(private myRoute:ActivatedRoute){}
	 
	 this.myRoute.params.subscribe((result)=>{})

  
  9.3 进阶用法--路由嵌套(routerOutlet/children)
   比如A组件，需要通过路由嵌套B组件、C组件
   ①给A组件模板内部指定一个容器
    <router-outlet></router-outlet>
   ②给A组件的路由对象指定children
    {
      path:'a',
      component:A,
      children:[
        {path:'b',component:B}
      ]
    }
   
   创建组件:
    demo21-mail
    demo21-inbox
    demo21-outbox

    <a routerLink="/mail/inbox">收件箱</a>
    <a routerLink="/mail/outbox">发件箱</a>

  9.4 进行用法--路由守卫(CanActivate)
   路由守卫本质就是执行一些运算，判断可否允许来访问组件
   angular的路由守卫是靠实现一个服务来做的

   ①创建服务，实现CanActivate类中的canActivate方法，才可以实现路由守卫的角色
    
    ng g service my-guard

    export class MyGuardService implements CanActivate{
      canActivate(){
        //执行一些运算
        return boolean/Observable/Promise
      }
    }

   ②调用具备守卫功能的服务
    从路由词典中，找到要保护的路由对象，指定一个canActivate
    {
      path:'admin',
      component:AdminComponent,
      canActivate:[MyGuardService]
    }
    
  
  练习:
   ①完成两个组件类的创建和路由地址的指定
    demo23-index  --> index
    demo23-detail  --> detail
   ②demo23-index
      1、组件一旦加载之后，(HttpClient)请求http://localhost:8080/index这个地址，
      2、将返回的数据中的recommendedItems，渲染在视图（ul、li显示商品的title）
      3、li能够点击跳转到detail，同时将商品的pid作为参数发送过去
   ③demo23-detail
     接收传来的参数，显示在视图的h2:'这是id为1 的详情页'
    
 10、lifecycle
  https://www.angular.cn/guide/lifecycle-hooks

  ngOnInit 负责初始化工作
  ngOnChanges 负责在数据变化时
  ngOnDestroy 负责清理工作

 
四、Ionic
 1、概述
  Ionic = angular + ionicModule + icon + cordova(phonegap)
 
  移动端开发的3种常见形式:
   WebApp:采用前端技术来编写可以运行在手机浏览器中的，类似原生app效果的网页
  
   NativeApp:采用java/swift/kotlin/oc来调用由Google/Microsoft/Apple公司所提供的SDK(software development kit)来完成原生的应用的开发,是运行在手机OS的
   
   HybridApp:采用web前端技术和原生开发技术，来进行编程，而生成可以安装在手机OS中的app
   phoneGap/appcan/369clound....


  ionic可以实现webApp，也可以借助内部集成的cordova来实现hybridApp

  搭建环境:
   https://ionicframework.com/docs/v3/
   npm install -g ionic
   ionic start myApp tabs
   cd myApp
   ionic serve

  具体步骤：
   ①将C:\xampp\htdocs\codes\forStu\ionic_资料.zip解压缩到当前文件夹
   ②将C:\xampp\htdocs\codes\forStu\ionic模板\myProject.zip拷贝到C:\xampp\htdocs\codes\ionic
   ③将C:\xampp\htdocs\codes\ionic\myProject.zip解压缩到当前文件夹

     
 2、ionic中page的创建和调用
   创建：ionic g page demo01
   调用:
    ①到根模块中声明组件类/页面类
    ②在根模块中任何一个组件都可以调用新的页面类 
      作为根组件
      作为子组件
      路由来单独访问

   问题1：
    如果没有安装ionic？？
    ①将C:\xampp\htdocs\codes\forStu\ionic模板\ionic_cmd.zip解压缩到当前文件夹

    ②右键单击‘我的电脑’--》查看属性--》查看高级系统--》环境变量--》系统变量--》path--》新建，将指定的目录添加进去C:\xampp\htdocs\codes\forStu\ionic模板\node_modules\.bin

    ③记得将vscode编辑器关闭再重新打开
   问题2：
    执行ionic支持的指令，必须得在ionic工程中
   问题3：
    node版本要统一 8.11.1
   问题4:隐藏的问题
     在ionic中处理新的page，创建完页面类之后，修改数据或者模板之后，重启启动:ctrl+c,npm start
  

 3、ionic所提供的组件类的使用(重点)
   3.1 button
    ion-button
    color=‘primary蓝色/secondary绿色/danger红色/light浅灰色/dark黑色’ theme/variables.scss 修改$colors自定义设置
    block 
    clear 
    outline
    icon-left/right
     <ion-icon name=""></ion-icon>

   3.2 list （处理列表）
    ①普通列表
     <ion-list>
       <ion-item>文本1</ion-item>
       <ion-item>文本1</ion-item>
     </ion-list>
    ②icon列表
     <ion-list>
       <ion-item>
        <ion-icon item-start/end name="home"></ion-icon>
        文本1
       </ion-item>
       <ion-item>文本1</ion-item>
     </ion-list>
    ③头像列表avatar
     <ion-list>
       <ion-item>
        <ion-avatar item-start/end >
	 <img />
	</ion-avatar>
        文本1
       </ion-item>
       <ion-item>文本1</ion-item>
     </ion-list>
    ④缩略图列表thumbnail
     <ion-list>
       <ion-item>
        <ion-thumbnail item-start/end >
	 <img />
	</ion-thumbnail>
        文本1
       </ion-item>
       <ion-item>文本1</ion-item>
     </ion-list>
    ⑤支持侧滑动的列表项
      <ion-list>
       <ion-item-sliding >
        <ion-item>列表项1</ion-item>
        <ion-item-options side='left'>
          <button ion-button color='danger'>删除</button>
        </ion-item-options>
       </ion-item-sliding>
      </ion-list>
    ⑥下拉刷新(ionRefresher ionRefresh complete $event)
     步骤1：在ionContent的最上边指定一个组件
      <ion-refresher>
       <ion-refresher-content pullingText="" refreshingText="" pullingIcon="" refreshingSpinner="">
       </ion-refresher-content>
      </ion-refresher>

      spinner : ios/ios-small/bubbles	/circles/crescent/dots

     步骤2：绑定一个事件ionRefresh
      <ion-refresher (ionRefresh)="doRefresh($event)"></ion-refresher>
     步骤3：在事件处理函数中处理刷新这个操作，同时借助于参数在刷新之后，结束刷新动作
     doRefresh(myRefresher){     
       //异步操作结束之后，调用complete
       myRefresher.complete()
     }    
    ⑦上拉加载更多(ionInfiniteScroll ionInfinite complete $event)
     步骤1：调用组件放在ionContent最后的子元素位置
      <ion-infinite-scroll></ion-infinite-scroll>
     步骤2：绑定事件
      <ion-infinite-scroll (ionInfinite)="loadMore($event)"></ion-infinite-scroll>
     步骤3：在事件处理函数处理加载更多的操作之后，通知结束加载动画
       loadMore(myInfinite){
          //做数据处理
	  myInfinite.complete()
       }


    练习:(:- 16:50)
      ①完成demo03-lianxi这个页面类的创建、注册、调用(在根组件中通过rootPage来调用)
      ②在demo03-lianxi的组件类中准备一个数组
      [100,200,300]；将数组中渲染在视图，支持侧滑动列表项的列表，列表项显示数组中的数据，隐藏的按钮叫删除，点击删除，能够将当前的列表项从列表移除
      *ngFor="let tmp of myList;let myIndex=index"

      this.myList.splice(index,1)
   
   3.3 grid (自定义布局)
    栅格系统 是基于Flexbox
    基础用法:
     <ion-grid>
       <ion-row>
         <ion-col></ion-col>
       </ion-row>
     </ion-grid>

    常见配置:
      col-*设置列宽为*/12
      offset-* 设置距离左边的偏移量
      push-* 向右推
      pull-* 往左拉

      align-items-start/center/end 设置一行中所有列的纵向对齐：顶部、居中、尾部
      align-self-start/center/end 设置某一列在当前行中的纵向对齐
      justify-content-start/center/end 某一列在行中横向对齐左边、居中、右边

    练习:(:- 11:25)
      ①完成demo07-lianxi的创建、注册、调用
      ②指定一个数组，['商品1','商品2'。。。'商品8']
      将数据显示在视图，视图显示一行两列的效果

      思路：先去显示第一列
         
   3.4 slides (轮播图、新手教程...)
     pagingationType='bullets/fraction/progress'
     effect='slide/fade/flip/cube'

     <ion-slides autoplay=2000 loop pager
      paginationType='fraction' effect="slide" speed=1500
      direction='vertical'>
       <ion-slide>商品1</ion-slide>
       <ion-slide>商品2</ion-slide>
       <ion-slide>商品3</ion-slide>
     </ion-slides>

     注意事项:
       如果ionSlides中没有ionSlide，自动播放就会出错，建议在ionSlides执行一个条件判断:有没有可用的ionSlide(背后数组的长度是否为0)
  
   3.5 交互窗口
    3.5.1 loading 加载中
      ①引入并实例化
        import {LoadingController} from 'ionic-angular'
	constructor(private loadingCtrl:LoadingController){}
      ②创建
        var myLoading = this.loadingCtrl.create({
	  duration:1000,
	  content:'正在刷新。。。'
	})
      ③显示窗口
        myLoading.present()
       其它的方法:
        myLoading.dimiss()
	myLoading.setContent()  
    
    3.5.2 toast 通知(操作之后提示效果)
       ToastController
       this.toastCtrl.create({
         message:'通知内容',
	 duration:1500,
	 position:'top/middle/bottom',
	 showCloseButton:true,
	 closeButtonText:'关闭'
       })

    3.5.3 alert 警告/确认/输入提示
     AlertController 警告/确认/输入提示
     
     this.alertCtrl.create({
       message:'窗口要显示的内容',
       inputs:[
        {placeholder:'',type:''},
        {placeholder:'',type:''},
       ],
       buttons:[
         {text:'yes',handler:(list)=>{
	   //list[0]来获取第1个输入框输入的数据
	   //list[1]来获取第2个输入框输入的数据
	 }},
         {text:'no',handler:()=>{}},
       ]
     })


    3.5.4 actionSheet 多个选项中做选择
     ActionSheetController

     this.asCtrl.create({
       title:'',
       buttons:[
         {text:'分享到微博',handler:()=>{}},
         {
	   text:'取消',
	   handler:()=>{},
	   role:'cancel'
	 },
	 {
	   text:'删除',
	   role:'destructive'//会在ios中红色高亮显示
	 }
       ]
     })


     练习: (:- 16:20)
      ①完成demo11-lianxi的页面类的创建、注册、调用
      ②模板中指定一个按钮，点击按钮，显示一个输入提示窗口：一个输入框，两个按钮（确认/取消），点击确认，获取输入框的内容，
      显示一个toast：'已经将验证码发送到**'
      
      AlertController
      ToastController


    3.5.5 modal 自定义模态窗口

     ①基础用法
        ModalController
	import {PayPage} from '***'

	var myModal = this.modalCtrl.create(PayPage)

	myModal.present()
       
       模态窗口内部怎么实现关闭效果？
	import {ViewController} from 'ionic-angular'

	conscturctor(private viewCtrl:ViewController){}

	this.viewCtrl.dismiss()
	


     ②进阶知识
      模态窗口在关闭时 如果完成自定义参数的发送和接收？
       发送
         this.viewCtrl.dismiss(0)
       接收:
         myModal.present()
	 myModal.onDidDismiss((data)=>{
	   //data就是调用dismiss方法时传来的数据
	 })
	
    练习:
     ①完成demo13-lianxi的创建、注册、调用
     ②在demo13-lianxi页面初始化之后请求服务器端的数据
      localhost:8080/index

      HttpClientModule HttpClient

     ③将请求到的数据(carouselItems),显示在ionSlides,ionSlide显示商品的标题


   3.6 forms 表单元素
     表单在ionic中 是通过ionList来进行管理的，表单元素要放在ionItem中
	ion-label
	ion-input
	ion-checkbox
	ion-radio (radio-group)
	...(ion-range/ion-select/....)

   3.7 卡片
     卡片是为了更好的组织信息给用户看
     <ion-card>
       <ion-card-header></ion-card-header>
       <ion-card-content></ion-card-content>
     </ion-card>

   3.8 fab
     Floating Action Button悬浮式操作按钮
     使用套路:
      //left/right top/bottom center/middle
      <ion-fab right bottom>
        <button ion-fab></button>
	<ion-fab-list side="left/right/top/bottom">
	  <button ion-fab>btn1</button>
	  <button ion-fab>btn2</button>
	</ion-fab-list>
      </ion-fab>
     

   3.9 支持滚动的容器
    <ion-scroll scrollX scrollY>
    </ion-scroll>


   3.10 tabs
    tabs可以实现一个在页脚位置的导航条、工具条、选项卡栏

    思路：
     ①在视图中调用ionTabs
       直接删除自带模板的ionheader/ionContent,直接指定
       <ion-tabs>
         <ion-tab tabTitle="" tabIcon="" [root]="home"></ion-tab>
       </ion-tabs>
     ②给ionTabs中每一个ionTab指定 都被选中显示是哪一个页面

       import {HomePage} from '**'

        home = HomePage
     
     练习:(:- 14:15)
      ①完成页面类的创建、注册
       demo15-settings
       demo15-cart
      ②在demo15-tabs中点击tab时，希望分别加载demo15-settings demo15-cart
       提示关键词:tab的root
   
   3.11 导航系统
    跳转、传参、借助于lifecycle的钩子函数实现路由守卫
    ionic的导航系统要比之前vueRouter/AngularRouter简化：
      不再配置路由词典

    ①跳转
     this.$router.push()/<router-link to="">
     this.myRouter.navigateByUrl()/<any routerLink=""

      编程式导航:
       ①引入
        import {NavController} from  'ionic-angular'
        import {DestinationPage} from '**'
       ②实例化NavController
        constructor(private navCtrl:NavController){}
       ③跳转
        this.navCtrl.push(DestionationPage)
      标签(指令式)导航：
       import {DestinationPage} from '**'
       destPage = DestinationPage
       <any [navPush]="destPage"></any>
    ②传参       
        发送:
	 this.navCtrl.push(DestionationPage,{id:1})
	 <any [navPush]="destPage" [navParams]="{id:1}"></any>
	接收:
	 import {NavParams} from 'ionic-angular'
	 
	 constructor(private navParams:NavParams){}

	 this.navParams.get('id')
     
    练习:(:- 15:35)
      ①完成两个页面类的创建和注册
       demo17-list （根组件调用此页面，来默认显示）
       demo17-detail
      ②在demo17-list中 准备一个对象数组
       [{pid:0,title:'商品1'}，{。。。}]
       将对象数组的数据 渲染在ionList中，列表项显示title，点击列表项 跳转到demo17-detail,同时将pid发送过去
      ③在demo17-detail接收传来的参数，然后保存，到视图中h2显示



    项目目标：
     ①熟练使用ng的基本语法、网络通信、服务..
     ②熟练使用ionic常用的各组件(ionSlides/ionGrid/...)以及导航系统(push/navPush...)

     准备工作：
     ①将C:\xampp\htdocs\codes\ionic\myProject.zip拷贝到C:\xampp\htdocs\codes\ionic\xz,进入xz目录，将myProject.zip解压缩到当前文件夹
     ②工程需要的图片
     将C:\xampp\htdocs\codes\forStu\ajia_code的img目录复制，粘贴到C:\xampp\htdocs\codes\ionic\xz\myProject\src\assets目录

     this.myHttp.get(url,{withCredentials:true}).subscribe()

     this.myHttp.post(url,body,{withCredentials:true}).subscribe()


五、React

 常见错误：
    
   SyntaxError: embedded: Unterminated JSX contents  未结束的标签
 
 React技术栈/生态圈：
  ReactJS 编写网页
  ReactNative 编写原生的移动端的app
  React360 ReactVR项目的升级 虚拟现实的app
  Redux react管理数据和行为的
  第三方的开源项目(ReactNavgation/react-router...)

 slogan:learn once,write anywhere
  
 vscode中的一个扩展插件: live server

 浏览器的允许第三方cookie：默认都是允许的
  设置--》高级--》内容设置--》cookies--》不要阻止第三方的cookies


 1、ReactJS概述
  
  what?
   ReactJS是fb公司，推出的一个构建ui层的js库,和vue、angular作对比，react算一个View层
  
  when?
   主要用在数据操作比较频繁的场景下的web开发
  
  why?
   为什么推出？
    ①浏览器性能瓶颈
      VDOM(virtual DOM 虚拟DOM)
    ②开发和维护成本非常高
      单向数据流

  how?
   方式1：
    引入对应的js文件
   方式2：
    cli
        npx create-react-app my-app
	cd my-app
	npm start

  
  第一个案例：
   ①babel 是一个js的编译器，可以将es6或者更高级的语法、jsx转换为普通浏览器能够识别的js
   ②ReactDOM.render(a,b)
   ③jsx
    
 2、ReactJS的核心概念
   2.1 jsx 
     (JavaScriptXml)并不是一种新的语言，只是js的扩展，可以在js中直接写标签
     ReactDOM.render(
       <h2>{3+5}</h2>,
       document.getElementById('example')
     )
    
    jsx两大特征：
     ①遇到<，首字母是小写，会交给html解析；首字母是大写，会按照组件来解析处理
     ②遇到{，会交给js执行表达式

   2.2 component
     创建
      var Test = React.createClass({
        render:function(){
	  return <p></p>
	}
      })

     调用
      ReactDOM.render(
        <Test></Test>,
	document.getElementById('example')
      )

     注意事项：
       ①组件类的命名 遵循全驼峰 Test/MyComponent
       ②渲染多个标签，要放在一个顶层标记
       ③在render方法渲染元素时，如果return加换行，加上一个圆括号包起来
        return (
	  <div></div>
	)

	return <div>
	</div> 
       ④出现在react中的标签都得有开始有结束
        <input type='text'/>

     练习：(:- 11:30)
      ①创建一个demo04_lianxi.html文件
      ②完成组件类的创建和调用
       MyName/MyPwd/LoginButton/RegisterButton
       MyLogin
      ③调用ReactDOM的render方法将MyLogin渲染在id为example的容器中

   2.3 props
    review:
      vue:
        <son sonName='john'></son>
	Vue.component('son',{
	  props:['sonName'] //this.sonName
	})
      angular:
        <son sonName='john'></son>
	import {Input} from '@angular/core'
	@Input() sonName=""//this.sonName
     
    react:
     知识1：(基础用法、父子通信)
      ①传值
       <MyHeader myTitle="这是登录页面">
       </MyHeader>
      ②接收
       在MyHeader组件中接收通过myTitle属性给 传递的数据
	 this.props.myTitle
      
      练习:(:- 14:20)
       ①将demo04_lianxi实现的效果,用组件和属性传值重构--》demo06_lianxi.html
       ②MyInput MyButton MyLogin
       MyLogin = MyInput+MyInput+MyButton+MyButton
       
     知识2：（子与父通信）
      
      共识：在react中，可以通过自定义属性传一个普通的字符串，还可以传一个方法

      子与父通信的标准版流程:
      ①父定义一个有参数的方法
       rcv:function(msg){}
      ②将此方法传递给子组件
       <son func={this.rcv}></son>
      ③子组件来调用由参数方法，将数据传递到父组件
       this.props.func(123)

     
      兄弟通信：
       ReactJS中 并没有直接提供兄弟通信的解决方案：
        借助于共同的父组件来完成兄弟通信过程

     知识3：this.props.children
       组件类this.props对象中的keyValue，和调用组件时所指定的属性是一一对应的；其实有一个例外：this.props.children

       可以通过this.props.children来获取到组件在被调用时 内部的子元素

       注意事项：
        this.props.children类型是不确定的，如果一个字标签都没有：undefined
	如果只有一个：object
	如果有多个：array

	React中实现一个方法来方便的遍历this.props.children:

	React.Children.map(
	  this.props.children,
	  (value)=>{
	    return  value
	  }
	)


    事件处理：
     <button onClick={this.handleClick}>
     </button>
     <input onChange={this.handleChange}/>

   2.4 state
    功能1： 负责数据管理
     3个基础操作：
      ①初始化
       getInitialState:function(){
        return {count:0,price:100}
       }
      ②读
       this.state.count
      ③写
       this.setState({count:2})
       this.setState({count:2},()=>{
         //状态在写操作成功之后，会执行的处理函数
       })
       注意事项：
        如果一个组件中 有多个状态，在处理状态的写操作时，需要更新哪个状态直接设置，其它的默认保持不变
   
    功能2： 状态的数据具有绑定的效果
     一旦将状态的数据给视图使用，当状态发生变化时，视图也会跟着自动更新

    练习：(:- 16:55)
      demo10_lianxi.html

      ①实现一个组件，组件渲染一个按钮
      ②按钮按下，按钮中的文本内容：开、关  

   2.5 ref
     reference可以在父组件中 直接得到子组件的实例对象（子--》父）

     ①指定ref
      <son ref='mySon'></son>
     ②父组件通过ref调用子组件
      this.refs.mySon
     
     补充:
      <input type='text' ref='myInput'/>
      this.refs.myInput.value
  
   总结：
     jsx:进行组件化编程的一个基础
     component：完成视图的封装和复用
     props:
      ①父-》子 
      ②子-》父(通过属性传方法)
      ③children得到子标签
     state：①完成组件内部数据管理 ②绑定    
     ref:直接得到子组件或者html标签
    
    (:- 10:20)
   demo12_todobox.html
    ①完成组件类的创建和调用
    (:- 10:45)
    ②点击ToDoInput中的add时候，可以将输入框的值发送给ToDoBox（收到数据，打印）

	rcv(msg){}
	<son func={this.rcv}></son>
        this.props.func(123)
    (:- 11:25)
     ③在ToDoBox中保存ToDoInput传来的数据，保存到数组:
     初始化、写(每次收到子组件传来值)、读(ToDoList)
     ④ToDoList接收到ToDoBox传来的数据之后，动态的渲染多个ToDoItem
    this.props.myList.map(()=>{
      return <ToDoItem></ToDoItem>
    })

 3、ReactJS进阶知识

  3.1 生命周期
   学习react中组件的生命周期钩子函数，让在指定的时间处理特有的功能，举例：在组件销毁时，关闭定时器

   初始化
     componentWillMount
     componentDidMount 

   数据变化时做逻辑处理
    componentWillUpdate
    componentDidUpdate
    componentWillReciveProps：
    当组件被调用时，通过属性传来的值变化时，会执行的钩子函数，在此方法中是支持对状态做写操作
  
   清理
    componentWillUnmount

   注意事项：
    ①update相关的钩子函数 不可以调用setState
    ②通过属性传来的数据是只读的，如果有修改的需求，可以将值存在state

  
  整理：
    react组件的方法中，分为两大类：
     ①官方自带的
      getInitialState
      render
      componentWillMount/...
     ②自定义的方法
      handleClick
      addToList...

     编程规范：
      React建议大家将官方自带的方法 放到组件内部最前边（render放在最后边），中间放的方法就是自定义的
  
  练习:(:- 15:20) demo14_lianxi.html
    
    component,jsx,state,lifecycle hooks 

    ①在此文件中，创建一个组件，组件中模板内容：h1
    ②在组件挂载之后，启动一个定时器，修改h1的透明度
     0~0.1~0.2...~1
     1~0.9~0.8...0
     0~0.1~0.2...1

     style={{opacity:**}}
  
  3.2 受控元素
   在react中处理表单元素时候，如果表单元素指定了value/checked/selected等相关属性，称之为受控元素；与之相反的称为非受控的元素

   如何处理受控元素？？
     状态的3个基本操作
      初始化
      读 : this.state.**绑定到表单元素的value/selected/checked
      写 ：onChange e.target.value


  3.3 实现循环或者判断效果
    vue/angular:
      v-if *ngIf
      v-for *ngFor
      v-else-if/v-else *ngSwitchCase 
      ....
    
    react:并没有自己的指令，但是基于jsx非常方便的实现对应效果

    判断：
     方案1：短路逻辑(适用于判断条件相对简单)
       expression && <组件></组件>
     方案2：自定义方法(适用于判断条件相对复杂)
       showSth:function(){
         //计算
	 //拿到计算的结果做判断，判断之后，如果有需要，可以直接返回要渲染的内容
       }

       {
         this.showSth()
       }
    
    循环：
      {
        this.props.myList.map((value,index)=>{
	//value就是数据 index就是下标
	  return <li></li>
	})
      
      }

  
  3.4 事件处理函数自定义传值
    事件处理函数的写法：
      Vue:
        @click="handleClick"
        @click="handleClick(123)"
      小程序:
        bindtap="handleTap" 
      angular:
        (click)="handleClick(123)"
      React:
	<button 
          onClick={()=>this.handleClick(123)}>clickMe</button>
	<input onChange={()=>this.handleChange(123)}/>


  。。。。

 4、路由、网络通信。。。
   借助于第三方 的工具
   路由：react-router
    https://github.com/ReactTraining/react-router
   网络通信：
    fetch api（RN）

 
 5、React Native


六、ReactNative(RN)

 what?
  Build native mobile apps using JavaScript and React
  
  使用js和react中核心概念 构建移动端的NativeApp

  竞品：weex(vue)、flutter(Google dart)

 when?
  如果有reactjs的开发经验，可以使用ReactNative快速上手实现NativeApp
 
 how??
  搭建环境:
	npm install -g expo-cli //安装cli
	expo init AwesomeProject //创建模板项目

	cd AwesomeProject //进入到项目目录
	npm start //启动开发服务器

  1 pc端
    ①拷贝C:\xampp\htdocs\codes\forStu\rn_myapp.zip到C:\xampp\htdocs\codes\react\
    
    ②将rn_myapp.zip解压缩到rn_myapp

    ③用vscode打开指定的文件夹
    C:\xampp\htdocs\codes\react\rn_myapp
    
    ④启动开发服务器
     npm start
    
    ⑤检查运行是否成功
     在浏览器中输入:localhost:8081
  
  2 mobile端
    ①启动模拟器
     夜神、蓝叠、腾讯手游助手、网易mumu
    ②借助于手机上的app连接pc端运行的开发服器进行效果的预览
     如果模拟器当前没有安装myapp，
     直接找到C:\xampp\htdocs\codes\react\rn_myapp\android\app\build\outputs\apk\app-debug.apk
   ③设置
    打开app之后，设置要连接的服务器的ip地址和端口号
      cmd-->ipconfig

      172.163.100.163:8081 

      点击夜神模拟器右上角摇一摇--》DevSettings-->Debug Server Host & Port for device
      -->输入你的ip地址和端口号 类似      172.163.100.163:8081 
      
      关闭myapp（点击右下键--》近期任务--》滑动app），再重新打开
    
    app闪退：
     卸载myapp的应用
 
 开启/关闭 热更新：
  摇一摇--》Enable Hot Reloading
  摇一摇--》Disable Hot Reloading
 手工更新：
  摇一摇--》Reload
 远程js调试：
  摇一摇--》 Debug js Remotely
 
 1、组件的创建和使用
  
  es6的模块化注意细节：
   ①方案1
     export default class Demo01Component
     import Demo01  ...
     import Demo01Component ...
   ②方案2
     export class Demo01Component
     import {Demo01Component} ....

  创建一个组件：
    export default class Demo01Component extends Component{}
  调用组件：
    import Demo01Component from './src/components/demo01_first'

    作为子标签：
     <Demo01Component></Demo01Component>
    作为根组件:
     AppRegistry.registerComponent("myapp",()=>Demo01Component)
    路由来访问：
      ？？
   
   注意事项：
    ①所有的类 都得先引入 才可以使用
    ②一个组件类如果要渲染多个标签，要记得放在一个顶层容器
    ③不支持html标签
 
 2、数据处理
   state:负责组件内部的数据处理

     初始化：和reactjs的初始化有些差别
      constructor(){
        super();
	this.state = {count:1}
      }
      读状态
        this.state.count
      写状态
        this.setState({count:2})

   props:负责管理调用组件时传来的数据
    <son myTitle='123'></son>
    this.props.myTitle

   网络请求:
    get:
     fetch(url)
     .then((response)=>{
       return response.json()}
      )
     .then((result)=>{
      //result就是服务器端所返回直接操作的数据
     })
    post:
     var options = {
	  method: 'POST',
	  headers: {
	    Accept: 'application/json',
	    'Content-Type': 'application/json',
	  },
	  body: JSON.stringify({
	    firstParam: 'yourValue',
	    secondParam: 'yourOtherValue',
	  })
     }
     fetch(url,options)
      .then((response)=>{
        return response.json()
      })
      .then((result)=>{})

   练习:(:- 11:45)
    ①完成demo03_lianxi.js文件的创建和调用
     作为根组件调用
    ②模板内容 <Text>hello world</Text>
    ③在组件挂载完毕之后，启动定时器，修改Text的透明度
     0~0.1~0.2 。。。~1


 3、样式(StyleSheet)、布局处理
  在ReactNative所自带的封装好的组件，比如View/Text，都是支持style的设置

  样式的封装和调用：
   封装
    import {StyleSheet} from 'react-natives'

    var myStyles = StyleSheet.create({
      myText:{
       fontSize:10,color:'red',opacity:0.3
      }
    })

   调用:
    <组件 style={myStyles.myText}></组件>
 
 

 4、常用组件（重点）
  使用react中的核心概念，完成对于RN中所封装的组件的调用，从而来实现原生的app
   4.1 Text (p)
    Text功能:显示一段文本内容(直接显示对象是会报错的)
    import {Text} from 'react-native'
    
    this.state = {stu:{stuAge:10,stuName:'mike'}}

    <Text>{this.state.stu.stuName}</Text>
    <Text>{'\n'}</Text>
   
   4.2 View (div)
    View是一个容器，在容器中调用其它的组件
    import {View} from 'react-native'

    <View>
      ....
    </View>

    提醒：为什么View组件的子标签能够显示？？
     this.props.children
   
   4.3 Button 
    Button是一个按钮，可以指定在按下时执行对应的操作
    使用：
     import {Button} from 'react-native'
     <Button title="登录" onPress={this.handlePress}></Button>

     提醒：事件处理函数在定义时，要尽可能的符合箭头函数的形式，避免出现this指向的问题
    
   4.4 FlatList(基础)
    FlatList是一个高性能的列表组件，可以批量显示数据

    两个关键因素：
     ①显示什么数据
      data
     ②指定列表项的渲染方式
      renderItem
    
    使用:
     import {FlatList} from 'react-native'
     <FlatList data={this.state.list}
      renderItem={this.showItem}
     ></FlatList>
     
    注意：
      在渲染列表项时，如何知道要渲染的是数组哪条数据？？？
       renderItem所指定的showItem方法，是有参数有返回值的一个方法
       //info是一个对象，包含item/index
       showItem(info){
	 return <渲染的列表项内容></渲染的列表项内容>
       }

    综合练习：
     ①完成demo08_lianxi.js的文件的创建和调用
     ②模板：
       Button FlatList(显示列表项：Text)
     ③功能
       点击按钮时，请求数据http://172.163.100.**:8080/product/list
       将请求到的数据中data对应的数组， 保存在状态中，将数据渲染在FlatList（列表项在Text中显示商品的title）

     用到的组件：
      View,Button,FlatList,Text
     数据处理：
      ①state
        初始化，要放在构造函数中super方法之后
      ②fetch
        处理与远程服务器端的通信

   4.5 TextInput(ChangeText)
    功能：获取用户输入的信息
    使用:
     import {TextInput} from 'react-native'

     <TextInput 
     placeholder='请输入用户名' 
     secureTextEntry={true}
     onChangeText={this.handleChangeText}
     keyboardType="numeric/email-address"
     >
     </TextInput>
   
   4.6 Switch 开关(ValueChange)
    Switch默认就是一个受控的表单元素，大家可以按照受控组件的方式来处理：
     处理思路：正是状态的3个基本操作
     ①初始化
      constructor(){
        super()
	this.state = {myValue:true}
      }
     ②读
      <Switch value={this.state.myValue}></Switch>
     ③写(ValueChange)
      handleValueChange=(value)=>{
        //value记录就是当前开关准备切换的值
	this.setState({myValue:value})
      }
      <Switch 
      onValueChange={this.handleValueChange}
      value={this.state.myValue}></Switch>
    
    练习:(:- 10:55)
     ①完成demo10_lianxi组件的创建和调用
     ②模板
       TextInput
       Button
       FlatList(列表项是Text)
     ③功能
       点击按钮，获取输入框的值，显示在列表
       
       提示：初始化状态，2个 保存输入框的值 保存列表组件要显示的数组

   4.7 Image 图片
    html: <img src="...."/>
    两种情况：
     情况1：显示本地资源图片
      <Image source={require('../imgs/3.jpg')}></Image>
     情况2：显示网络资源图片
      <Image style={{width:100,height:100}} source={{uri:"http://172.163.100.163/3.jpg"}}></Image>
      <Image
       style={{width:250,height:250}}
       source={{uri:"http://172.163.100.163/"+this.state.imgName}}
       ></Image>
    
    注意事项：
     ①在使用Image组件显示各种图片时候，有可能会出现图片的路径、信息都是正确的情况下，不显示或者出错
       从rn的工程中移除调用，再重新拿找可用的图片试试
     ②本地资源图片在加载时，require方法中不允许做任何的计算
     ③网络资源图片是支持动态设置的
     ④网络资源图片在显示时，需要明确指定宽高，否则是不会显示的
    
     test：
      ①将3.jpg放到C:/xampp/htdocs
      ②启动xampp的apache服务
      ③测试localhost/3.jpg是否可以访问
      ④到RN中读取网络资源图片
         <Image style={{width:100,height:100}} source={{uri:"http://172.163.100.163/3.jpg"}}></Image>
   
   4.8 TouchableOpacity 容器 添加交互效果
    容器，放在此容器中的元素在按下时，会有交互效果
    import {TouchableOpacity} from 'react-native'

    <TouchableOpacity onPress={}>
      ...
    </TouchableOpacity>

    ①按下时 会有透明度变化效果
    ②支持绑定press事件

   4.9 ScrollView
     支持滚动的容器
     import {ScrollView} from 'react-native'

     <ScrollView></ScrollView>

     ScrollView有一个特征，默认情况会占据能够占据的高度；

     利用此特征可以实现固定在页脚的效果:
      <View style={{flex:1}}>
        <ScrollView></ScrollView>
	<View>
	  ...
	</View>
      </View>
    
    练习：(:- 15:30)
     ①完成demo14_lianxi组件的创建和调用
     ②模板
       ScrollView  Text（支持按下时交互）
     ③功能
       在组件中准备一个对象数组 pList(准备5条数据，每个对象包含id、title)
       通过循环在ScrollView中创建多个Text(可以将Text放在TouchableOpacity，显示商品的title)
       点击Text时，弹出窗口(alert),显示商品的id
  
   4.10 ActivityIndicator
    功能：告诉用户当前有个活动正在进行，类似loading

    <ActivityIndicator color="" size="large/small"></ActivityIndicator>


   4.11 FlatList(进阶)
    ①FlatList是一个比较特殊的组件，将状态给data属性，需要配合着extraData才能完成一个绑定效果
     <FlatList 
     extraData={this.state}
     data={this.state.list}></FlatList>
    ②加载更多
      只需要绑定事件
       onEndReached={this.handleEndReached}

       onRefresh

    ③避免key的问题
      {
        this.state.list.map((value,index)=>{
	  return <Text key={index}></Text>
	})
      }

      FlatList解决key的问题是数据源头着手
       
       this.state = {
         myList:[
	   {title:'商品1',key:0}，
  	   {title:'商品2',key:1}，
	   {title:'商品3',key:2}
	 ]
       }

       <FlatList data={this.state.myList}></FlatList>
    

   4.12 布局
    在ReactNative中 没有额外的布局的学习成本 ，因为是依然可以使用FlexBox
    flexDirection主轴(默认是column)
    justifyContent 沿着主轴的对齐
    alignItems 沿着交叉轴的对齐

  
  

 5、导航系统
  ReactNative官方框架并没有内置导航系统，目前使用量最多的是一个第三方的开源工程:
   ReactNavigation
  
  概述：
   ReactNavigation是给ReactNative来使用的，一个可以实现路由和导航功能的库
  
   

  怎么用？
   ①安装react-navigation
    yarn add react-navigation
    # or with npm
    # npm install --save react-navigation
   ②引入react-navigation
    import {createStackNavigator} from 'react-navigation'
   ③创建组件 引入组件
    import Demo18LoginComponent from '**'
    import Demo18MainComponent from '**'
   ④完成路由的设置和调用
    var myNavigator = createStackNavigator({
      //路由系统 默认会显示一个keyValue
      myLogin:{
       screen:Demo18LoginComponent
      },
      myMain:{
       screen:Demo18MainComponent
      }
    })
    AppRegistry.registerComponent('myapp',()=>myNavigator)

    

   ⑤跳转
     回顾 
       vue: this.$router.push
       angular:this.myRouter.navigateByUrl()
       ionic:this.navCtrl.push()
     
     ReactNavigation:
       this.props.navigation.navigate('目的地路由地址')

   ⑥传参
       回顾：
         ①配置接收方的路由地址
	  /detail --> /detail/:id
	 ②发送
	 ③接收
	  vue: this.$route.params
	  angular:this.myRoute.parans (ActivatedRoute)
       
       ReactNavigation:
        发送：
	 this.props.navigation.navigate(
	  'confirm',{id:1,price:20,name:''})
        接收：
         this.props.navigation.getParam('id')
	 this.props.navigation.getParam('price')
 
   练习:
     ①完成两个组件类的创建、并分配路由地址
      demo20_list 路由地址:list(默认)
      demo20_detail 路由地址:detail
     ②模板
	demo20_list： FlatList Button
	demo20_detail： Text
     ③功能
	 demo20_list:
	准备一个字符串数组 this.state = {myList:['商品1'...]}，将数组显示在FlatList中，列表项显示字符串，点击列表项中的按钮，跳转到detail，将下标传递
	demo20_detail:接收传来的数据并保存，显示在Text




 项目：使用RN来实现学子商城的后台管理界面
 目标：
   ①熟练掌握React中的核心概念、核心思想(Everything is Component)、开发理念（learn once,write anywhere）
   ②熟练掌握React中数据的处理
    state、props、fetch
   ③熟练掌握ReactNative所各种组件的用法
    FlatList Button TextInput Image
    ScrollView ....

 
 扩展：
  StyleSheet的一种进阶用法
 
  var myStyles =  StyleSheet.create({
    myBorder:{},
    myCol:{}
  })

  <组件 style={myStyles.myBorder}></组件>
  <组件 style={[myStyles.myBorder,myStyles.myCol]}></组件>


七、Python
  可以使用的IDE（集成开发环境）:
    vscode pycharm

  目标：
   ①学会python这门编程语言中的基础语法、标准库的使用、面向对象编程、异常处理。。。
   ②基于python的第三方库 操作数据库、搭建前端网站
   ③采用python、django、vue实现一个项目

  常见错误:
   ①NameError: name 'name' is not defined
    调用了已经释放调的变量
   ②IndentationError: unexpected indent
    缩进错误
   ③TypeError: must be str, not int
    不可以将数字和字符串做加法运算
    
    TypeError: 'tuple' object does not support item assignment
    元组是不允许进行写操作


   ④ValueError: invalid literal for int() with base 10: 'chengji'
    int("chengji")
   ⑤IndexError: list index out of range
    操作数组下标越界了
   ⑥AttributeError: 
   'dict' object has no	attribute 'stuName'
    读取字典对象中不存在的属性
   ⑦SyntaxError: invalid syntax
    
  
  关键字:
   py help('keywords')
   
   False/def/if/raise/None/del/import/return
   /True/elif/in/try/and/else/is/while
   as、except、lambda、with、assert、finally 、nonlocal、yield
   break、for、not、class、from 、or、continue、global、pass
  
  1、概述
    what?
      python是一门编程语言，最早时是为了方便维护计算机开发设计的
    where?
      前端开发、数据分析、PC级别的GUI、系统集成
    why?
      ①语法简洁
      ②跨平台
      ③丰富的类库
      ④开源
      。。。。
    
    how?
     ①变量、数据类型
     ②方法、运算符
     ③循环、条件判断
     ④面向对象
     ⑤异常处理
     。。。

    版本:
     2.* 不再维护
     3.* 现在和未来
      
    怎么安装?
     下载https://www.python.org/downloads/windows/对应的python的安装包
     或者FTP中/22_PYTHON/DAY01/的python-3.6.5.zip

     双击打开，直接安装(提示2点：①同意 ②添加到环境变量)

     https://docs.python.org/3/tutorial/index.html
  
  2、了解运行方式
    2.1 注释：
      行注释:#
      块注释：三个单引号或者三个双引号
    
    2.2 运行方式：
     ①编写一个py文件 （运行脚本）
       py **.py
     ②REPL (通过py直接解析)
       怎么进入解析模式：
         py
       怎么退出解析模式？
         exit()或者quit()
    
    2.3 输出 输入
      print("向屏幕的终端输出一句话")
      #格式化输出
      print('小米买了%d,花了%f,%s给我一个折扣'%(count,price,uname))
      input() #获取用户的输入信息
      input("请输入:")

    2.4 获取方法的使用方式
     方案1：利用集成的cli工具通过help查看
       py
       help(print)
     方案2：查看在线文档
      https://docs.python.org/3/library/index.html

  3、变量
    变量的命名不要和关键词冲突，应该是有字母数字下划线构成，不可以以数字开头

    定义:
      age = 20
    读：
      print(age)
    写:
      age = 30
    释放:
      del age

  4、数据类型
    4.1 如何查看类型: type(age) 

    4.2 number 
     int float complex boolean
  
    4.3 string
      两个单引号：''
      两个双引号：""
      3个单引号：''' 这里头允许换行'''
      3个双引号：''' 这里头允许换行'''
     
     练习:(:- 17:30)
       ①完成demo04_lianxi.py文件的创建
       ②分别获取用户所输入的语文成绩、数学成绩
       ③将平均值算出来，输出:"平均值是**"

       input/print/int/格式化/str
    
    4.4 list
     myList = [10,20,30]
     myList[0]
     myList[0] = 2
     myList.append(10)#尾部
     myList.insert(index,value) #向指定的位置插入数据
     myList.pop()#删除最后一个
     myList.pop(2)#删除下标为2的元素
     myList.sort() 升序
     myList.sort(reverse=True) 降序

     max(myList)
     min(myList)
     len(myList) #得到数组的长度

    4.5 tuple
     元组就像是带了手铐的数组，不能写
     myTuple = (100,200,300)
     #读取元组的值
     myTuple[0]
     #修改元组的值 --不支持

     注意事项:如果元组中只定义一个元素，记得逗号隔开
      myTuple = (100,)
     
     max(myTuple)
     min(myTuple)
     len(myTuple)

    4.6 dict(dictionary 字典)
     字典是键值对的组合，查找比较快,key必须用引号引起来

     定义?
      myDict = {"age":20,"name":"lucy"}
     读写?
      myDict.get('age')
      myDict['age']=21
      myDict['score'] = 80
      myDict.pop('name')
     练习:(:- 10:50)
       ①demo08_lianxi.py
       ②通过input分别获取用户所输入的商品的单价、商品的名称、商品的数量
       ③存在一个字典中
       ④输出："商品1花费30元"

    4.7 set 
     是存储不会重复的数据的无序集合

     mySet = set([100,200,200,300])
     mySet = {100,200,300}
     mySet.add() //增
     mySet.remove() //删除
    
    显式类型转换的方法:
     int()
     str()
     float()
     set()
     list() #转换为数组
     tuple() #转换为元组
     ....

  5、运算符
   5.1 算术运算
    +-*/ % // **
   5.2 比较运算(关系运算)
    > >= < <= == !=
   5.3 赋值运算
    += -= *= /= (不支持++ --)
	age = 20
	myList3 = [100,200]
	[score1,score2] = myList3
	score3=score4=20
	score5,score6=30,40
   5.4 逻辑运算
    and or not

    练习:(:- 14:15)
      ①demo11_lianxi.py
      ②通过input获取用户所输入的年份
      ③如果是闰年，输出True，否则Flase
       能被4整除但不能被100整除的年份
       或者能被400整除
   5.5 位运算
    & | ~ ^(不同就是1，相同就是0) << >>
   5.6 成员运算符
    在数组、元组、字典中判断是否存在这个成员，返回值是True/False
    in /not in

    注意事项:
     字典中判断成员时，只支持判断key是否存在
   5.7 身份运算
      is 用法： a is b 判断a和b这两个变量的id是否一致

      id(变量)  变量在内存中的一个地址（唯一的识别符）

 
  6、控制流(循环、条件)
   程序的设计是由3种结构：顺序、循环、选择

   6.1 循环
     for tmp in 集合:
       循环的代码结构
     
     for tmp in range(len(myList)):
       print(tmp,myList[tmp])

     while expression:
       循环体
       #break结束循环
       #continue直接进入到下一次循环

     提醒：
      ①冒号（英文） 
      ②缩写 py是靠缩进来组织代码
      ③range
      range(stop)/range(start,stop)/range(start,stop,step)
      range(3) 0 1 2
      range(1,3) 1 2
      range(1,10,2) 1 3 5 7 9

   6.2 选择
    不支持switch/case/default


    if expression:
      pass
    else:
      pass
    
    多重分支:
    if expression1:
      pass
    elif expression2:
      pass
    elif expression3:
      pass
    else:
      pass
    
   import random
   num = random.randrange(10)

   练习:demo15_lianxi.py (:- 16:25)
   ①生成100以内的随机数
   ②在循环中，猜数字
    输入的数字比随机数小：‘太小了’
    输入的数字比随机数大：‘太大了’
    猜对了，‘数字猜对了’，直接退出循环
    

  7、方法
   7.1 基础
    7.1.1 定义
     def myFunc(arg1,arg2):
        pass
	return ***
    7.1.2 调用
     myFunc(1,2)
    
    注意：
     ①实际调用方法的参数和方法定义时的形参要保持一致
     ②如果写了多个返回值，其实是一个元组
   
   7.2 参数的进阶用法
     7.2.1 可变长参数(自由的指定多个参数)
       def test(*args):
         #元组
       def func(**args):
         #字典
       test(1,2,3)
       func(num1=1,num2=2)
     
     7.2.2 默认值参数(偷懒)
       def test(host,port=3306):
	  print(host,port)

       test('localhost')
       test('172.163.100.163',3307)

     7.2.3 关键字参数(不用关心顺序)
       def add(num1,num2):
	 pass

       add(3,5)
       add(num2=5,num1=3)

     练习：demo19_lianxi.py
      ①定义一个方法，calc
        此方法支持可变长参数
	支持返回值：返回所有的参数的平均值
        
	calc(70,80) #75
        calc(70,80,90) #80
      ②定义一个方法，myDel
        此方法支持两个参数，第一个：数组，第二个：整数（默认值参数，默认0）
	功能：从数组中删除指定下标的元素
      ③定义一个方法 calcFactorial
        支持一个参数:整数
	返回值：该整数的阶乘
	calcFactorial(3) 3*2*1 = 6
	calcFactorial(10) 10*9*8..*1

  8、作用域以及闭包(LEGB/global/nonlocal/lambda/@)
   L(local局部作用域)
   E(Emebedded 嵌套函数作用域)
   G(Global 全局)
   B(BuildIn python内置)
   L>E>G>B

   8.1 局部
    定义在方法内部的变量，不会造成全局的污染，只可以用在方法内部
    def func():
      num=10
    
   8.2 全局
    直接在python文件中定义的变量，在任何一个地方都可以调用
    count = 0
    def func():
      global count#这当中的count就是全局变量count
      count+=1
      print(count)

   8.3 嵌套函数
      闭包：外层函数在调用时，有一个自己的作用域对象；内层函数在调用时，通过自己的__closure__属性引用外层作用域对象；在外层函数执行结束之后，无法释放掉，形成一个闭包的结构,变量依然保存在内存中，从而实现在内层函数中可重用的效果

      def outer():
        count=0
	def inner():
	  nonlocal count
	  count+=1
	return inner

   8.4 python内置
    type/max/min/len...
    
    练习:(:- 11:20)
     demo21_lianxi.py
     ①准备一个方法 getList,在此方法中 定义一个数组userList,一个内层函数login(这个login方法有参数，将参数追加到userList数组,打印userList)，返回内层函数
     ②调用外层函数getList,接收返回值，调用内层函数3次
   
   匿名函数:
     lambda定义的小功能，如果要做复杂的事情不建议使用lambda，可以单独定义方法处理

     lambda :3+5
     lambda num:num**2
     lambda num1,num2,num3:(num1+num2+num3)/3

   装饰器:
     在python所谓的装饰器，本质就是一个方法
     目标：在不修改原有代码的情况下，对代码进行功能的扩展
     使用场景:用户认证、日志处理、性能测试、权限校验。。。

     基础知识: 
      定义装饰器函数：
      ①形式：本质是一个方法，嵌套了函数
      ②功能：第一件实现装饰器要做的功能扩展 第二件是执行原有代码
       def checkLogin(func):
         def handle():
	   #执行扩展功能。。。
	   func()
	 return handle

     
      调用装饰器函数:
       @checkLogin
     
     进阶用法:
       def log(func):
         def handle(*args):
	   print('一个方法被调用了')
	   func(*args)
	  return handle
       
       @log
       def register(uname,upwd):
         pass

       @log
       def jump():
         pass



     练习:
      demo25_lianxi.py(:14:45)
      ①准备一个方法login，方法内部输出login success
       记得调用login方法
      ②创建一个装饰器
       功能：负责记录日志信息     
       具体：在这个log装饰器函数中，扩展一个功能：输出‘有一个方法被调用了’
       记得给login方法调用装饰器


  9、异常处理(try/except/finally/raise/as)
   回顾:js try catch finally
     try{}catch(err){}finally{}


   python:
    try:
      #执行一段代码
    except NameError:
      #进行异常处理
    finally:
      #无论try要执行的代码是否会出错，都会再次执行finally的代码
    
    补充:
      #方法1：捕获所有有可能会出现的错误
	except Exception as msg:
	  print('出错了',msg)
      #方法2：在一个地方，直接指定有可能会出现的各种错误
	except (TypeError,ValueError):
	  print('出错了')
      #方法3：挨个捕获，挨个处理
	except ValueError:
	  print('值有问题')
	except TypeError:
	  print('数据类型有问题')

   进阶知识：
     自定义错误消息内容、接收
        try:
	  #做一些代码的处理
	  raise(TypeError('这是一个自定义的错误消息内容'))
	except TypeError as msg:
	  print(msg)#msg就是TypeError在触发时传来的信息
     

  10、模块与包(import from )
   es6:
     export 
   commonJS:
     module.exports = 

   模块module：就是一个py文件,是数据和方法的封装
   包package：就是一个文件夹，可以有多个模块，是多个模块的封装

   学习重点:
     模块之间的调用：
       方式1：
         from demo29_cart import submit
	 from demo29_cart import *
	 submit()
       方式2：
         import demo29_cart
	 demo29_cart.submit()

	 import demo29_cart as cart
	 cart.submit()
       
       进阶用法：
         当模块按照*号引入时，如何限制哪些属性或者方法可以被引入??
	 __all__=['submit','addToCart']

        
     包之间的调用:
        方式1：
         from user.demo29_cart import submit
	 from user.demo29_cart import *
	 submit()
        方式2：
         import user.demo29_cart
	 user.demo29_cart.submit()

	 import user.demo29_cart as cart
	 cart.submit()
	方式3：
	 from user import order
	 from user import *
        
	进阶用法：
	  包中的模块在被按照*全部引入，如果需要限制：
	   ①在包中新建一个文件
	     __init__.py
	   ②在__init__.py指定一个变量
	   __all__=['order']
        
	 
	练习:(:- 17:50)
	 ①创建一个包：cart，在cart包中新建一个模块 manageCart.py,在这个模块中指定两个方法(方法内部输出一句话)
	  addToCart
	  delFromCart
	 ②在当前工程根目录下，新建一个模块
	 demo31_lianxi
	  在这个模块中，按照"from user import order"引入上一步包中的模块，调用内部的方法


  11、oop(Object Oriented Programming)
   面向对象编程！
    将现实生活中具体的业务 封装成一些类
    3大基本特征:
      封装、继承、多态
    
    11.1 封装
      class Ticket():
        oid=0
	content=""
	def __init__(self,id,ct):
	 pass

	def calcPrice(self,arg1):
	  #self.oid
      
      实例化Ticket类为一个对象:
       t = Ticket(100,10,'---')
       #t.oid
       t.calcPrice(11)
      
      注意事项:
        ①如果在类中要封装一些方法，无论这个方法是否需要参数，都得给指定一个参数self
	②构造函数的名字必须__init__
	③调用类进行实例化时，参数的个数和类型 要和构造函数在定义时 保持一致
      
      练习:demo33_lianxi.py(:- 10:50)
       ①封装一个类
         Car 封装drive的方法("***正在行驶")，封装属性:brand
	 构造函数指定一个参数来描述brand属性
       ②类进行实例化，调用对象中的方法

    11.2 继承、多态  
     继承
       ①继承的方式
        //Order就是DeliveryOrder类的基类、父类、超类
        class DeliveryOrder(Order)
       ②扩展
         在子类调用父类中构造函数做初始化??
	 super().__init__(***)
     多态：
       可以直接通过方法的重写来实现多态
     
     练习:demo36_lianxi.py
      ①封装一个类
        Monestor
	  hp 初始化100
	  run方法：‘小怪兽正在移动。。’
      ②封装一个类
        Boss继承自Monestor
	  hp 初始化1000
	  run方法:'大Boss正在移动。。'
      ③实例化、调用
        输出hp
	调用run方法
     


  12、标准库和第三方库
    标准库:
      json
      math
      random
      time
      os.path
      ...
    第三方库:
      mysql

      回顾:
        npm i mysql
	var mysql = require('mysql')
	...
      python内置一个包管理工具:pip
	 pip install **
	 pip search **
	 pip show **
	 pip uninstall **
      
      在python中如果要使用mysql，得安装一个驱动(包)
         pip install mysql-connector
         
	 替换方案：
	  https://pypi.org/project/mysql-connector/#files 下载源代码包
	  解压缩，通过来离线安装：
	  python setup.py install
      
      
      使用具体步骤：
       ①引入
        import mysql.connector as conn
       ②连接数据库
        myConection = conn.connect(
	  host="localhost",
	  user="root",
	  passwd="",
	  database='xz'
	)
       ③创建游标对象
         myCursor = myConnection.cursor()
       ④通过游标对象执行sql语句
         myCursor.execute('select * from xz_user')
       ⑤通过游标对象获取sql执行的结果
         myCursor.fetchall()

       进阶处理：
         ①如果执行sql语句需要动态的数据
	  方案1:
 	   start = 0
	   myCursor.execute('select * from xz_user limit'+ start+',5')
	  方案2：(推荐)
	   start = 0
	   count = 10
 	   myCursor.execute('select * from xz_user limit %s,%s',(start,count))
         ②在sql操作中 涉及到修改、增加、删除的操作，必须再执行：
	  myConnection.commit()
	 ③数据库连接池
	    import mysql.connector.pooling as pooling
	    # 创建连接池
	    myPool = pooling.MySQLConnectionPool(
		  pool_size=10,
		  host="localhost",
		  user="root",
		  passwd="",
		  database="xz"
		)
	     # 从连接池中获取一个可用的连接
	     myConnection = myPool.get_connection()

	     练习:demo40_lianxi.py(:-16:40)
	     ①通过input来获取用户名和密码
	     ②通过python调用mysql.connector连接数据库，将用户名和密码插入到xz_user表中
	     提醒:commit %s



八、Django
   pip install django
   
   目标:
     ①基础指令
       #创建工程
       django-admin startproject ** 
       
       #启动工程的开发服务器
       py manage.py runserver 

       #在当前的project中创建一个app
       py manage.py startapp **

       #project是自带admin，创建用户
       py manage.py createsuperuser

       #激活模型类
       py manage.py makemigrations
       py manage.py migrate

     ②路由系统
      建立起url和视图之间的映射关系
      localhost:8000/admin
      app/views.py 创建视图
      app/urls.py 负责设置二级路由
      project/urls.py 负责一级路由

     ③ORM
      操作模型类的实例对象 来完成CRUD
      item = CartItem()
      item.title = ""
      item.save()
      CartItem.objects.values()
      item = CartItem.objects.get(id=1)
      item.title = "111"
      item.delete()/save()

     ④模板系统
      步骤1：创建模板
       {{count}} 
       {% for tmp in pList%}
       {% endfor %}
       {% if expression %}
       {% else %}
       {% endif %}
      步骤2: 加载模板
        tpl = loader.get_template()
	tpl.render({"count":10})

 
   1、Django概述
    Django makes it easier to build better Web apps more quickly and with less code.

    Django是一个基于python的全栈框架，可以帮助用更少的代码 更方便的来实现前端网站！

    特点:
     ①集成度比较高，功能比较强大
     内置了完善的路由系统、模板系统、后台数据管理功能。。。
     ②基于django的工具也非常多
     ③强大的后台管理系统
    。。。

   2、完成一个基于Django的工程的创建和运行
     ①进入C:\xampp\htdocs\codes\django
     ②在此目录中创建一个工程
      django-admin startproject xz
     ③用vscode打开C:\xampp\htdocs\codes\django\xz文件夹
     ④运行功能
      py manage.py runserver
      localhost:8000
      localhost:8000/admin 

   3、使用路由系统
     路由：建立起一种url和视图之间的映射关系


     基础：project 和 app
       一个project可以包含多个app，举例：一个新浪网站(project)，可以包含军事、时事、邮箱。。(app)；
     在当前的django的project中创建一个app：mail
     py manage.py startapp mail

     设置路由的具体步骤：
      ①创建视图
	mail/views.py
	
	from django.http import HttpResponse
	# Create your views here.
	def handleIndex(req):
	  return HttpResponse("hello django")

      ②设置二级路由(app内部的路由)
        创建mail/urls.py，设置
	from . import views
	from django.urls import path

	# 设置二级路由（app内部的路由）:路由信息得放在urlpatterns数组中，名字不要写错了！！
	urlpatterns = [
	 path("index",views.handleIndex)
	]
      ③设置一级路由(project指向app的路由)
        xz/urls.py

	from django.urls import path,include

	urlpatterns = [
	    path('admin/', admin.site.urls),
	    path('mail/',include('mail.urls'))
	]

     练习:(:- 10:30)
     ①创建一个app:user
     ②配置路由
     localhost:8000/user/ “这是个人中心首页”
     localhost:8000/user/login “这是登录”
     localhost:8000/user/register“这是注册”
      步骤1：创建视图
      步骤2：配置路由
        
   4、ORM
     不用写sql，按照对象的操作，就可以实现数据库中数据的增删改查(Object Relational Mapping 对象关系映射)

     完成一个app的创建和注册：
      创建：py manage.py startapp product
      注册:xz/settings.py 
        INSTALLED_APPS=[
         'product',
	 ...
        ]#一旦注册之后，再makemigarations按照这个列表生成迁移文件；否则模型类是无法激活和使用

    具体流程:
     ①在product这个app中完成模型类的定义和激活(models.py migrate)
      product/models.py
      
      class ProductItem(models.Model):
        #定义属性和类型（类似定义表结构）
      
      将模型类映射到数据库(激活):
       py manage.py makemigrations #创建一个迁移的准备文件
       py manage.py migrate #迁移到数据库
      
      注意事项:
       模型类只要发生了变化，生成迁移文件，再去迁移才会生效

     ②使用模型类来完成数据的CRUD(save/all/values/delete/get)
       from .models import ProductItem
       #向ProductItem表中添加一个数据
        item = ProductItem()
	item.title = ""
	item.price = 100
	item.save()
       
       #查询ProductItem所有的数据
        ProductItem.objects.values() #取数据
	ProductItem.objects.all() #取对象
       #条件查询
       #修改操作
       #删除

     ③使用后台管理系统直接以可视化的方式操作数据
       知识点1：创建admin网站有效的用户名和密码
        py manage.py  createsuperuser
	注意：输入密码是不会显示，密码最少8位，不能全是数字

       知识点2：如何将app内部的模型类 添加到admin网站？？
        product/admin.py

	from .models import ProductItem
	admin.site.register(ProductItem)
   
    练习:(:- 14:40)
     ①在当前的project中 完成一个app的创建和注册(settings.py)：cart
     ②配置路由(视图和url映射)
        localhost:8000/cart/list 返回获取列表成功
        localhost:8000/cart/add 返回添加成功
     ③完成一个模型类的创建和激活(migrate)
      CartItem：title字符串/count整数
      
      py manage.py makemigrations
      py manage.py migrate

     ④实现views中收到请求之后的具体业务
     /cart/list 返回CartItem的商品列表
     /cart/add?title=123&count=1 解析、保存、返回
     ⑤扩展
      将模型类注册到后台admin网站，方便查看
     
     CRUD常见操作:
       ①添加
        方式1：
	  item = CartItem()
	  item.title = ""
	  item.count = 1
	  item.save()
	方式2:
	  item = CartItem(title='商品1',count=20)
	  item.save()
       ②删除
          item = CartItem.objects.get(id=1)
	  item.delete()
       ③查找
          全部查找：
	   CartItem.objects.values()
	  条件查找:
	   CartItem.objects.get(title='商品1')
       ④修改
           item=  CartItem.objects.get(title='商品1')

	   item.count+=1

	   item.save()
   
   补充：
     django可以扮演服务器的角色，接收用户的请求，连接数据做增删改查，给予响应
     
     注意：应该返回的json格式的字符串
      import json
      json.dumps() 序列化
      json.loads() 反序列化

      处理模型类的实例的json序列化：
        item = CartItem.objects.get(id=pid)
	myDict = item.__dict__ #读取模型对象中的字典属性，可以得到一个字典
        myDict.pop('_state')
        result = json.dumps(myDict)
        return HttpResponse(result)

   5、模板系统
    Django这个框架遵循MVT的设计模式
     M:model 模型类/数据
     V:views 接收用户的请求，完成业务功能，加载模板展示给用户
     T:template 模板视图
    
    localhost:8000/news/list 返回一个无序列表

    django不仅仅可以扮演服务器提供API接口，有着完善的模板系统，创建html文件，动态的渲染数据。。。

    模板语法:
        <h2>{{count}}</h2> #计算count的值
	<h3>{{pList.1}}</h3> #读取数组的值

	#for循环
	{% for tmp in pList %} 
	 <h4>{{tmp}}</h4>
	{% endfor %} 
	
	#if判断
	{% if count >= 10 %}
	    <h1>count是大于等于10</h1>
	{% else %}
	    <h1>count是小于10</h1>
	{% endif %}

    步骤:
      ①创建一个模板文件
        对于目录结构有着严格的要求:
	news/templates/news/**.html

	举例：假设当前cart的app需要模板，
	cart/tempaltes/cart/**.html
      ②加载模板文件(还可以动态传值、支持循环、条件判断)
       #引入加载器
       from django.template import loader
       #加载模板
       tpl = loader.get_template('news/list.html')

       #渲染模板的内容
       result = tpl.render()
       #render方法是支持传递参数，参数必须得是一个dict

       #将内容返回给客户端
       return HttpReponse(result)
     

    练习:(:- 17:35)
    ①完成app的创建和注册
      military
    ②完成模型类的创建和激活
      WeaponItem
       name 字符串 skill 字符串
    ③完成模板文件的创建
      weaponList.html 返回一个ul
    ④指定路由系统
     localhost:8000/military/add?name=m16&skill='点射' 将数据插入到数据库

     localhost:8000/military/list 返回一个html文件，将数据库中的武器列表动态的选在ul li显示武器名字

   6、进阶知识
    跨域问题??
     ①准备一个vue项目
     npm i
     npm start (默认端口是8080)
     ②在vue中 点击按钮，发请求（请求通过django所写的后台API）
     ③如何解决跨域问题？？
      django处理步骤：
        步骤1：安装
	 pip install django-cors-headers
	步骤2：将app注册到工程
	 settings.py
	  INSTALLED_APPS=['corsheaders']
	  MIDDLEWARE = [
	    'corsheaders.middleware.CorsMiddleware'
	  ]	  
	步骤3：设置跨域规则
	 # 设置白名单
	 方案1：
	 CORS_ORIGIN_ALLOW_ALL = True
	 方案2：
	 CORS_ORIGIN_WHITELIST = ('http://localhost:8080')

    post请求解析参数？？
     get请求: req.GET['title']
     post请求:

     注意：django的工程默认是不允许接收post请求，如何设置允许接收？？
     ①允许接收
      settings.py /MIDDLEWARE
      注释调用此行代码:
      'django.middleware.csrf.CsrfViewMiddleware'
     ②接收post请求对应数据？？
       str = req.body.decode('utf-8')
       myResult = json.loads(str) #将json格式的字符串 转换为一个方便操作的数据 myResult.get('uname')

     练习:(:- 11:40)
      ①后端 
        实现了military/register的api，接收post请求中所传来的数据，返回
	{"code":200,"msg":"zhangsan register success"}
	{"code":301,"msg":"忘记指定用户名或者密码"}
      ②前端
       在当前的vue的HelloWorld.vue组件中，实现两个输入框，分别获取用户名和密码；实现一个按钮，点击按钮将用户名和密码通过post请求发给后端


九、项目的重构
 目标:	 
   Django完成后台的api处理、数据库的操作
    Vue完成前端页面





